<!DOCTYPE html>
<html lang="en">
<head>
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Eirik Website Eirik</title>
    <link rel="icon" type="image/png" href="imgs/icon.png" />
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link href="https://fonts.googleapis.com/css2?family=Magra:wght@400;700&display=swap" rel="stylesheet" />
    <link rel="stylesheet" href="style.css" />
  <title>Audio Recorder with Trim</title>
  <style>
    body { font-family: sans-serif; padding: 2rem; }
    button { margin: 1rem 0; }
    ul { list-style-type: none; padding: 0; }
    li { margin-bottom: 0.5rem; }

    .sidenav {
      height: 100%;
      width: 0;
      position: fixed;
      z-index: 1;
      top: 0;
      left: 0;
      background-color: #111;
      overflow-x: hidden;
      transition: 0.5s;
      padding-top: 60px;
    }

    .sidenav a {
      padding: 8px 8px 8px 32px;
      text-decoration: none;
      font-size: 25px;
      color: #818181;
      display: block;
      transition: 0.3s;
    }

    .sidenav a:hover {
      color: #f1f1f1;
    }

    .sidenav .closebtn {
      position: absolute;
      top: 0;
      right: 25px;
      font-size: 36px;
      margin-left: 50px;
    }

    @media screen and (max-height: 450px) {
      .sidenav {padding-top: 15px;}
      .sidenav a {font-size: 18px;}
    }
  </style>
</head>
<body>
<!-- Side navigation -->
<div id="mySidenav" class="sidenav">
  <a href="javascript:void(0)" class="closebtn" onclick="closeNav()">&times;</a>
  <a class="active" href="/">Home</a>
  <a href="/questions">Questions</a>
  <a href="/tts">IETTS</a>
</div>

<!-- Open buttons (outside the sidenav) -->
<span style="font-size:30px;cursor:pointer" onclick="openNav()">&#9776; open</span>

<!-- JavaScript -->
<script>
function openNav() {
  document.getElementById("mySidenav").style.width = "250px";
}

function closeNav() {
  document.getElementById("mySidenav").style.width = "0";
}
</script>
  <h1>Audio Recorder with Trim by Volume</h1>
  <button id="record">Start Recording</button>
  <button id="loadClips">Load Saved Clips</button>
  <audio id="player" controls></audio>
  <ul id="clipList"></ul>

  <script>
    const recordButton = document.getElementById('record');
    const loadClipsButton = document.getElementById('loadClips');
    const player = document.getElementById('player');
    const clipList = document.getElementById('clipList');

    let audioContext, mediaRecorder, chunks = [], analyser, source;

    async function startRecording() {
      const stream = await navigator.mediaDevices.getUserMedia({ audio: true });

      audioContext = new AudioContext();
      source = audioContext.createMediaStreamSource(stream);
      analyser = audioContext.createAnalyser();
      analyser.fftSize = 2048;
      source.connect(analyser);

      mediaRecorder = new MediaRecorder(stream);
      chunks = [];

      mediaRecorder.ondataavailable = e => chunks.push(e.data);
      mediaRecorder.onstop = async () => {
        const blob = new Blob(chunks, { type: 'audio/webm' });
        const arrayBuffer = await blob.arrayBuffer();
        const audioBuffer = await audioContext.decodeAudioData(arrayBuffer);

        const trimmed = trimBuffer(audioBuffer);
        const wavBlob = audioBufferToWavBlob(trimmed);

        const url = URL.createObjectURL(wavBlob);
        player.src = url;
        saveToIndexedDB(wavBlob);
      };

      mediaRecorder.start();
      recordButton.textContent = "Recording... (3s)";

      setTimeout(() => {
        mediaRecorder.stop();
        recordButton.textContent = "Start Recording";
      }, 3000);
    }

    function trimBuffer(buffer) {
      const raw = buffer.getChannelData(0);
      const threshold = 0.05;
      let start = 0, end = raw.length;

      for (let i = 0; i < raw.length; i++) {
        if (Math.abs(raw[i]) > threshold) {
          start = i;
          break;
        }
      }

      for (let i = raw.length - 1; i >= 0; i--) {
        if (Math.abs(raw[i]) > threshold) {
          end = i;
          break;
        }
      }

      const newBuffer = audioContext.createBuffer(1, end - start, buffer.sampleRate);
      newBuffer.copyToChannel(raw.slice(start, end), 0);
      return newBuffer;
    }

    function audioBufferToWavBlob(buffer) {
      const length = buffer.length;
      const sampleRate = buffer.sampleRate;
      const wavBuffer = new ArrayBuffer(44 + length * 2);
      const view = new DataView(wavBuffer);

      function writeString(view, offset, string) {
        for (let i = 0; i < string.length; i++) {
          view.setUint8(offset + i, string.charCodeAt(i));
        }
      }

      // RIFF chunk
      writeString(view, 0, 'RIFF');
      view.setUint32(4, 36 + length * 2, true);
      writeString(view, 8, 'WAVE');
      writeString(view, 12, 'fmt ');
      view.setUint32(16, 16, true);
      view.setUint16(20, 1, true);
      view.setUint16(22, 1, true);
      view.setUint32(24, sampleRate, true);
      view.setUint32(28, sampleRate * 2, true);
      view.setUint16(32, 2, true);
      view.setUint16(34, 16, true);
      writeString(view, 36, 'data');
      view.setUint32(40, length * 2, true);

      const channel = buffer.getChannelData(0);
      let offset = 44;
      for (let i = 0; i < channel.length; i++, offset += 2) {
        const s = Math.max(-1, Math.min(1, channel[i]));
        view.setInt16(offset, s * 0x7FFF, true);
      }

      return new Blob([view], { type: 'audio/wav' });
    }

    function saveToIndexedDB(blob) {
      const request = indexedDB.open("audioDB", 1);
      request.onupgradeneeded = event => {
        const db = event.target.result;
        db.createObjectStore("clips", { autoIncrement: true });
      };

      request.onsuccess = event => {
        const db = event.target.result;
        const tx = db.transaction("clips", "readwrite");
        const store = tx.objectStore("clips");
        store.add(blob);
        tx.oncomplete = () => db.close();
      };
    }

    function loadClipsFromIndexedDB() {
      const request = indexedDB.open("audioDB", 1);
      request.onsuccess = event => {
        const db = event.target.result;
        const tx = db.transaction("clips", "readonly");
        const store = tx.objectStore("clips");

        const getAllRequest = store.getAll();
        getAllRequest.onsuccess = () => {
          const clips = getAllRequest.result;
          clipList.innerHTML = '';

          clips.forEach((blob, index) => {
            const li = document.createElement('li');
            const audio = document.createElement('audio');
            audio.controls = true;
            audio.src = URL.createObjectURL(blob);
            li.textContent = `Clip ${index + 1}: `;
            li.appendChild(audio);
            clipList.appendChild(li);
          });

          db.close();
        };
      };
    }

    recordButton.addEventListener('click', startRecording);
    loadClipsButton.addEventListener('click', loadClipsFromIndexedDB);
  </script>
</body>
</html>
